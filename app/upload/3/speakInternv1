
Em xin phép trình bày về các nội dung đã tìm hiểu trong quá trình thực tập sinh tại bizfly. Nội dung sẽ gồm 3 phần: phần 1 trình bày về hệ điều hành Linux là môi trường chủ yếu mà mình sẽ sử dụng khi làm việc. Phần 2 sẽ trình bày về các khái niệm liên quan đến networking cũng như các công cụ trên Linux để chúng ta thao tác mạng. Phần 3 sẽ đề cập đến các loại ảo hóa, các công cụ ảo hóa để xây dựng nên các máy ảo, thành phần chính của các hệ thống dịch vụ điện toán.
Đầu tiên, em sẽ lướt qua một chút về lịch sử của Linux. Linux là một hệ điều hành mã nguồn mở nhân UNIX, một hệ điều hành được tạo ra từ đời tống, 1969, bằng ngôn ngữ B và sau được cải thiện bằng ngôn ngữ C. Linux được tạo ra bởi một lập trình viên là Linus Torvalds, bằng cách dựa trên một phần của dự án GNU là GNU C Compiler. Nói qua một chút thì dự án GNU là một dự án mã nguồn mở với mục đích đối lập với sự khép kín của UNIX, nhưng dự án vẫn thiếu một phần quan trọng là kernel. Vì vậy sự kết hợp giữa GNU và kernel của Torvalds đã tạo nên Linux, hay tên khác GNU/Linux. Do tính chất mở của cả Kernel và GNU nên ai cũng có thể tùy biến cho mình các phiên bản GNU/Linux khác nhau. Các distro đầu tiên có thể kể đến như là Slackware hay distro thương mại đầu tiên như Redhat vào đầu những năm 90.
Hệ điều hành mã nguồn mở Linux có một sức mạnh tuyệt vời bởi các công cụ dòng lệnh của chúng. Việc thao thác dòng lệnh trên Linux được triển khai thông qua shell. Linux shell về cơ bản là một giao diện nằm giữa kernel và người dùng. Nó chịu trách nhiệm cung cấp môi truờng dòng lệnh để người dùng thao tác với kernel bằng cách thông dịch các lệnh của người dùng sang các chương trình có sẵn để thực thi các chức năng. Shell có nhiều loại như sh là bornce shell, phổ biến nhất là bash Bornce again shell, ngoài ra còn các loại shell khác như : csh, dsh, ksh, zsh. 
Trên slide là một ví dụ khi người dùng nhập lệnh cowsay trên shell. Và để mà hệ thống hiểu được lệnh cowsay sau đó in ra output như màn hình thì nó sẽ cần một file bin có chức năng in ra output như vậy.
Để đầy đủ thì đúng ra là cần phải chỉ định cả đường dẫn đến nơi chứa file bin mới có thể thực thi được. Nhưng vậy thì hơi dài dòng nên Linux sử dụng một biến môi trường tên là PATH để lưu những đường dẫn thường chứa các file bin để tiện tìm kiếm. 
Biến môi trường là nơi chứa các thông tin dữ liệu về hệ thống để phục vụ cho việc thực thi shell. Ví dụ như biến PATH lưu các thư mục chứa tệp thực thi nhị phân, hay biến pwd chứ đường dẫn ở thư mục hiện hành. Thêm nữa là các lệnh thực thi có 2 dạng, 1 là internel cmd được tích hợp sẵn trên shell và 2 là external cmd được ta cài thêm vào. 
Vì là trình thông dịch nên các hoạt động trên Linux được xử lý thông qua luồng. Có 3 luồng là dòng vào tiêu chuẩn sdtin, dòng ra tiêu chuẩn stdin, dòng lỗi tieue chuẩn stderr. Các thao tác lệnh được nhập từ bàn phím sẽ được gửi vào stdin, xử lý và in kết quả ra thông qua stdout. Nếu có lỗi, stderr sẽ được sử dụng. Ta có thể thao tác với các luồng bằng nhiều cách như redirection hay piping.
Redirection có nghĩa là ta thay vì sử dụng các dòng tiêu chuẩn, ta có thể chuyển hướng sang nơi khác như là file. Trên màn hình là một số ví dụ về việc redirection. Lệnh 1 redirect output vào file thay vì stdout. Lệnh 3 chuyển hướng lỗi vào file. Và lệnh 6 là lệnh redirect input.
Còn piping cơ bản là redirect output sang input để thực thi một lệnh khác. Như ví dụng ở lệnh 2 trên slide.
Việc thao tác các file text có thể thông qua các text editor. Phổ biến nhất và được các sysadmin khuyên dùng là vim. Vim là một text editor được cải tiến từ vi, một text editor tích hợp trên Linux. Hiện nay một số bản distro thì tích hợp sẵn vim còn một số thì không. Ví dụ như bản ubuntu desktop 22 của em thì phải tự cài. Vim có các mode cơ bản là : normal - mode khởi đầu và là mode trung gian để chuyển các mode khác. Mode visual để bôi đen một đoạn nội dung file. Mode insert để viết vào file. Mode ex để thực hiện các thao tác với file. Nói chung đây là một text editor rất tiện lợi để sử dụng.
Tuy nhiên nhược điểm của vim, là vì là text editor nên nó không redirect được. Vậy nên trong một số trường hợp, các lệnh xử lý text được ưu tiên hơn. Ví dụ như lệnh cat. 
Xử lý text hay text processing được chia làm 6 loại, việc chia này do em tự chia sau khi tham khảo các tài liệu. Đầu tiên là nhóm lệnh file-combining cmd, có chức năng gộp file, gồm các lệnh cat, join, paste. Cat có chức năng nối các file lại với nhau và in ra màn hình, join thì nối các file theo chiều ngang nhưng phải dựa trên một trường chung giữa 2 file. Còn paste thì join nhưng không yêu cầu gì. Nhóm tiếp theo là nhóm file transforming cmd, chuyển đổi dữ liệu. Gồm tac, và split. Tác có chức năng ngược với cat, in ngược toàn bộ file. split có chức năng tách file thành các file nhỏ hơn. Nhóm thứ 3 là nhóm file formatting, định dạng file, gồn có nl, sort, uniq. nl có chức năng đánh số dòng, sort có chức năng sắp xếp và uniq sẽ loại bỏ các từ trùng lặp trong file. Nhóm thứ 4 là nhóm file viewing cmd, xem dữ liệu, gồm head, tail, less. Head xem một số dòng đầu của văn bản, tail xem một số dòng cuối của file, less thì xem file dưới dạng stdout giống như cat nhưng có thể cuộn lên xuống. Nhóm thứ 5 là file summarizing, tóm tắt dữ liệu, gồm wc và cut. wc có chức năng đếm dòng, từ hoặc bytes trong file. cut có chức năng thao tác tệp dựa trên các cột và trích xuất các cột cụ thể. Nhóm cuối cùng là nhóm các lệnh khác, nhóm này gồm 2 lệnh là sed và awk. sed xử lý dữ liệu theo các dòng và có thể thay thế, lọc trong văn bản. Còn Awk thì chủ yếu dựa dùng để xử lý file theo các cột. Awk được thiết kế giống như một ngôn ngữ lập trình.
Các biểu thức chính quy trong Linux hỗ trợ rất tốt với việc xử lý văn bản, một số biểu thức chính quy thường dùng được hiển thị trong bảng trên slide. Ví dụ như nó có thể kết hợp với grep để tìm kiếm tốt hơn. Như lệnh 1 là để tìm tất cả các từ bắt đầu bằng ký tự B. Lệnh 2 tìm kiếm các từ kết thúc bằng ký tự B. Lệnh 4 tìm kiếm các địa chỉ ipv4 có subnet 24. còn lệnh 5 tìm kiếm các giao diện mạng có tên ens.
Khi thực hiện các lệnh trên linux, một số lệnh sẽ yêu cầu chúng ta đợi rất lâu, nếu chỉ đợi thì rất mất thời gian. Giải pháp cho việc này là chạy các lệnh dưới dạng background process.
Trên slide là ví dụ cho việc chạy process dưới dạng bg process. Em sẽ đề cập đến ở slide sắp tới.
Đề cập đến process là khá quan trọng, vì các lệnh trong linux đều được coi là process. Mỗi process sẽ có các pid riêng biệt, nếu process được tạo bởi một process khác, nó sẽ có thêm ppid là pid của process tạo ra nó. Các init process là process được thực thi đầu tiên trên hệ thống, có pid=1. Daemon là các process chạy ngầm trong hệ thống, ví dụ như sshd luôn chạy để mở cổng 22 chờ các kết nối ssh. Một số process khi chạy bị lỗi, chúng đã hoàn thành công việc của mình nhưng không thể kết thúc. Ta có thể kết thúc các tiến trình bằng lệnh kill.
Lệnh kill sẽ gửi các signal đến để nhân thực hiện các hành động với process. Các kill signal được đề cập ở trên slide bao gồm 62 kill signal. Một số signal chủ yếu được dùng là: 9 17 19.
Quay lại về foreground và background process. Foreground process là những lệnh mà bình thường ta chạy và đợi chúng thực hiện xong kết quả thì sẽ viết lệnh tiếp theo. Còn background process là những lệnh chạy nền mà trong lúc nó thực hiện ta có thể viết các lệnh khác. Bg process có thể được khởi chạy bằng cách chuyển từ foreground process hoặc chạy lệnh trực tiếp trong nền. Để chuyển từ fore sang back, ta send stop signal sau nó gõ bg để chuyển chúng sang background process. Để chạy trực tiếp trong nền, ta gõ lệnh với ký hiệu và ở sau. Muốn quản lý các bg process, ta sử dụng lệnh jobs. Lệnh jobs sẽ hiển thị list các bg process cùng với id của chúng. Để kill hoặc chuyển chúng trở lại fg process, ta sử dụng kill, fg cùng với %<pid> của chúng.
Để xem toàn bộ các loại process đang chạy trên máy, một command hay được sử dụng là ps. Trên slide là một số ví dụ cho ps.
Mỗi thiết bị lưu trữ có một tốc độ đọc ghi nhất định, và nếu các tiến trình chạy cùng lúc, chúng sẽ được chia đều hiệu suất đọc ghi. Để ưu tiên hiệu suất cho một tiền trình nào đó, ta sử dụng lệnh nice, các tiến trình có giá trị nice càng thấp thì càng được ưu tiên. 
Để quản lý các tiến trình, ta có hai công cụ hữu ích là htop và top. Htop có chức năng xem các tiến trình đang chạy dưới dạng real-time giống như window task manager. 
Còn top thì xem các process được chụp trong một thời gian, ảnh chụp được cập nhật vài giây một lần, mặc định là 3s.
Điểm qua một số option của top...
Linux lưu trữ mọi thứ từ các thiết bị i/o đến các process hay bất cứ thứ gì dưới dạng 1 file.
Các file này được gắn vào một thư mục duy nhất gọi là root(/). Cấu trúc thư mục root có một số file mặc định được gọi là FHS. mỗi file sẽ có một chức năng riêng biệt, như bin lưu trữ các file nhị phân, dev lưu trữ thông tin về các thiết bị i/o, etc lưu trữ thông tin cấu hình các ứng dụng,...
Để tìm kiếm các file trong cây thư mục, có 4 lệnh thường được sử dụng là ...
Trên Linux, các thông tin mỗi file có thể được xem bằng lệnh ls -l. Các thông tin cơ bản như thông tin inode, ngày tháng tạo file, người sở hữu, group sở hữu hay các thông tin phân quyền truy cập
Các file có thể được phân quyền truy cập cho người dùng với umask. Umask là 3 bit nhị phân tương ứng với các quyền tương ứng như read, write, excute. Ta có thể đặt quyền này bằng lệnh chmod với 3 umask liên tiếp. Thứ tự cho các umask là dành cho người sở hữu, nhóm sở hữu, và người dùng khác.
Các file cũng có thể được sao chép, di chuyển hay xóa với các lệnh tương ứng như cp, mv hay rm.
Trường thông tin inode trong lệnh ls -l cho biết thông tin về các hardlink file. Linux có 2 khái niệm là hardlink và softlink. Hardlink là hai file được trỏ đến cùng một đơn vị dữ liệu và chúng phải trong cùng một thư mục, còn soft link thì giống shortcut trong window và softlink có thể ở khác thư mục với file gốc. Để tạo link file, ta sử dụng lệnh ln.
Các file trên linux, thường được nén với công cụ tar. Công cụ tar hỗ trợ nén và giải nén các định dạng thường dùng như *.tar, *.tar.gz, *.tar.bz2.
Thông tin các user trong file được lưu trong /etc/passwd, còn thông tin group và các thành viên của gr được lưu trong /etc/group. Và ta có thể chỉnh sửa các thông tin này như thêm, xóa user hay group.
Các ứng dụng của linux có thể được cài đặt thông qua một số cách như qua package management như apt của debian hay yum trên redhat. Build từ source qua trình biên dịch GNU make, hay chạy file cài đặt với dpkg trong các bản Debian Linux. Trong việc cài đặt file thì có một số khái niệm cần lưu ý là Repo, depend pack, conflict pack. Repo là một file lưu trữ các thông tin về nguồn của các ứng dụng. Khi ta cài bằng apt thì nó sẽ tìm kiếm các nguồn để tải ứng dụng qua cái repo này. Các ứng dụng có thể yêu cầu một số ứng dụng khác kèm theo gọi là depend pack. Trong trường hợp cac ứng dụng kèm theo đã được cài đặt trên máy nhưng phiên bản lại không phù hợp thì nó sẽ bị conflict. Để tránh các source bị lỗi thời thì ta có lệnh cập nhật cho apt là apt-update, apt-update sẽ cập nhật lại nội dung mới nhất của Repos, còn apt-upgrade sẽ dựa vào nội dung repos để cập nhật phiên bản mới nhất cho các ứng dụng đã cài trên máy.
Các ổ đĩa gắn vào linux để được sử dụng thì phải tạo các partition, các partition để có thể lưu dữ liệu thì phải tạo filesystem trên đó rồi mount vào cây thư mục. Linux hỗ trợ một số filesystem như: ext, ext2, ext3, ext4, BtrFS, XFS, JFS, swap. Mình có thể xem các filesystem đã được mount bằng lệnh df. Ngoài ra còn có lệnh du để xem dung lượng các file đã chiếm trong thư mục. Em cho vào slide này là vì nó viết gần giống với lệnh df nên tiện luôn.
Nói về việc tăng dung lượng lưu trữ trong linux thì mình có 2 công nghệ hay sử dụng là raid và lvm. Raid thì có cả raid cứng và raid mềm. Raid có một số loại như Raid 0, raid 1, raid 5, raid 10. ..
Công nghệ thứ 2 là lvm, lvm là công nghệ giúp tạo các ổ đĩa ảo từ các ổ đĩa cứng bằng cơ chế device mapping. Sử dụng lvm có các lợi thế như dễ dàng nâng cấp dung lượng, có thể nâng cấp ngay khi máy tính đang chạy. Ví dụ như ta có thể tăng dung lượng cho phần lưu trữ đã được mount vào root. LVM có một số khái niệm như PV, VG, LV, PE, LE. Các ổ đĩa hay partition khi được sử dụng cho LVM sẽ được tạo thành các PV. các PV được gom chung trong một VG và từ VG có thể tạo ra LV. Các LV thực chất được ánh xạ từ các PV trong VG. Phần được ánh xạ trong PV là PE còn trong LV là LE.
Trên slide là một số ví dụ về các chức năng mà lvm có thể làm ví dụ như tạo, xóa, tăng giảm dung lượng, tạo lv dạng raid 0 hay raid 1. migrate dữ liệu trên LV.
Backup dữ liệu cấu hình, đổi tên, tạp snapshot hay cấp phát động.
Quá trình nạp và khởi động của Linux cũng là một phần cần được đề cập, thứ tự khởi động của linux sẽ được thực hiện lần lượt qua 6 giai đoạn. ..
Với các init thì hiện tại các bản distro thường dùng systemd. Ngoài ra còn có sysvinit cũ hơn nhưng vẫn được sử dụng trên một số bản linux như ubuntu. Sự khác biệt chính thì systemd sử dụng systemctl để quản lí các service, dùng các target để khởi động hệ thống còn SysV thì dùng service để quản lí, và dùng các run level init.
Syslogd
Để quản lý log dễ hơn ta có thể dùng log rotate. Log rotate được lưu trữ ở trong file /etc/logrotate.conf và thư mục /etc/logrotate.d/
Các tùy chọn cấu hình đầy đủ của log rotate được lưu ở trên slide.
Việc tự động hóa các tác vụ cũng khá quan trọng, ta có thể dùng cron hoặc at. ta sẽ sử dụng để lập lịch các tác vụ một cách thường xuyên, sử dụng at để thực hiện tác vụ giống như báo thức.
Một việc cần thực hiện nữa là sao lưu dữ liệu trong Linux, ta có thể sao lưu với các công cụ như dd, rsync. 
Hay rsnapshot, rsyncrypto.
Trên đây là toàn bộ nội dung em trình bày về phần Linux. Phần tiếp theo sẽ liên quan đến Network và các công cụ network trên Linux.

Network là mạng lưới kết nối các thiết bị lại với nhau. Đầu tiên phải nói về mô hình OSI. Mô hình OSI là một tiêu chuẩn truyền thông mạng máy tính. Tiêu chuẩn này chia nhỏ việc truyền thông phức tạp thành các tác vụ nhỏ hơn, dễ hiểu hơn. Gồm 7 tầng là : ... Tuy nhiên việc thiếu linh hoạt của mô hình này trong thực tế khiến cho mô hình TCP/IP được ưu tiên hơn. TCP/IP giống như là một mô hình rút gọn của mô hình OSI. Nó chỉ có 4 tầng là ... Ngoài ra còn cung cấp thêm giao thức UDP để thích ứng với các trường hợp cần tốc độ cao. Tuy nhiên là mô hình OSI vẫn luôn được nhắc đến như một mô hình tham chiếu và đi kèm với TCP/IP do sự phân chia rõ ràng của nó.
Một trong những giao thức quan trọng nhất trong TCP/IP phải kể đến là IP, giao thức IP là giao thức hướng dữ liệu, nằm ở tầng 3 trong mô hình TCP/IP. IP đóng vai trò như địa chỉ nhà của các thiết bị trong mạng. Giao thức IP có 2 phiên bản đang được sử dụng là IPv4 và IPv6.
IPv4 là giao thức phổ biến hơn với cách biểu diễn địa chỉ IP thông qua 32 bit. Các bit được chia thành 4 octet, mỗi octet 8bit. Tương ứng với mỗi octet có giá trị tối đa là 255. Trên hình là ví dụ về một địa chỉ IPv4. 
Địa chỉ IPv4 được chia thành 5 lớp. Lớp A bắt đầu bằng bit 0 ở octet đầu và các lớp sau mỗi lớp chèn một bit 1 lên đầu. tùy vào quy mô của tổ chức hay người sử dụng mà sẽ dùng các class tương ứng.
IPv4 có hỗ trợ chia subnet để tận dụng việc lãng phí các địa chỉ khi một tổ chức không sử dụng hết lượng IP mình thuê, subnet giúp chia các địa chỉ IP thành các mạng con. Có 2 cách viết subnet, cách 1 là viết subnet mask dưới dạng thập phân ngay sau địa chỉ IP với ký hiệu source, cách 2 là viết subnet mask dưới dạng bit nhị phân. IPv4 phổ biến như vậy nhưng hiện tại nó gặp khá nhiều vấn đề như thiếu hụt IP để cấp cho các thiết bị, không có khả năng bỏa mật.
Vì vậy, IPv6 ra đời, địa chỉ IPv6 có tới 128 bit và được chia thành 8 nhóm, mỗi nhóm 16 bit, được cách nhau bằng dấu hai chấm và biêủ diễn bằng số hexa cho gọn. 8 octet chia làm 3 phần với tỉ lệ 3-1-4 tương ứng với phần global.., .. và ...
IPv6 có các quy tắc để viết cho gọn, là nếu một hoặc nhiều octet được đặt liên tiếp nhau, nó sẽ bỏ đi. Tuy nhiên chỉ được bỏ 1 khối octet toàn 0 khi viết địa chỉ. IPv6 mang lại khá nhiều lợi thế khi sử dụng tuy nhiên nó vẫn còn chưa phổ biến. 
Vấn đề tiếp theo khi nói đến network là mạng LAN- Local Area network. Mạng LAN là một mạng private nằm trong một miền quảng bá được tạo thành bởi một thiết bị định tuyến như router hay modem. Các host trong mạng sử dụng địa chỉ IP private. 
Mạng VLAN là một mạng LAN ảo nằm trong mạng LAN được tạo ra bởi các switch với mục đích bảo mật, dễ quản lý. Các vLAN có thể giao tiếp với nhau hay không tùy vào việc định tuyến của các switch. Một vLAN có thể nằm trên 2 switch khác nhau, đường dây kết nối giữa 2 switch đó có thể có nhiều vlan đi qua được gọi là trunking.
Bonding là việc gộp hai hay nhiều interface mạng làm 1 nhằm tăng bandwidth và cân bằng lỗi. Bonding có 7 chế độ là: ...
Tương tự thì etherchannel là một công nghệ tăng bandwidth và cân bằng lỗi nhưng dựa trên việc gộp các đường kết nối có cùng chỉ số lại với nhau. Etherchannel có 2 chuẩn là LACP theo IEEE và trên các thiết bị cisco có PagP.
ARP là giao thức phân giải địa chỉ IP sang địa chỉ MAC. Giúp cho các máy tính có thể biết được nơi để gửi gói tin đến. Giao thức ARP được sử dụng bằng cách bên yêu cầu gửi broadcast các gói ARP request tới các máy khác trong mạng để hỏi về một địa chỉ IP. Máy nào có địa chỉ IP tương ứng khi nhận được sẽ gửi lại gói tin phản hồi cùng với địa chỉ MAC tương ứng của chúng. 
Trong cấu hình mạng, việc cấp phát IP động được sử dụng thông qua giao thức DHCP. Quá trình yêu cầu cấp phát địa chỉ IP bằng DHCP gồm 4 bước. Bước 1 máy client sẽ gửi đi gói tin quảng bá DHCP Discover với địa chỉ nguồn là 0.0.0.0. Bước 2 DHCP server nhận được gói tin discover sẽ kiểm tra danh sách địa chỉ IP chưa sử dụng và gửi một gói tin offer cho máy client thông qua địa chỉ MAC của gói Discover. Bước 3, nếu đồng ý, máy client sẽ gửi lại gói tin quảng bá DHCP request để yêu cầu xác nhận. Bước 4, máy server xác nhận bằng cách gửi gói tin ACK cho client. Kết thúc quá trình yêu cầu cấp phát.
Trong trường hợp mạng có nhiều hơn 1 DHCP server, client sẽ chọn ra máy server đầu tiên mà nó nhận được gói tin offer.
Phòng trường hợp địa chỉ IP mà server cấp đã được sử dụng, server sẽ tiến hành gửi gói tin ICMP để kiểm tra xem đã có máy nào dùng IP đó chưa. Nếu có tín hiệu trả lời thì server sẽ chọn địa chỉ IP khác. 
Giao thức tiếp theo em muốn đề cập đến là giao thức phân giải địa chỉ, DNS, giao thức này...

DNS có nhiều loại bản ghi, bản ghi SOA record duy nhất trong mỗi tập tin cơ sở dữ liệu chứa các thông tin về domain trên DNS server. Name server record 
Giao thức tiếp theo khá quan trọng khi sử dụng web server là giao thức HTTP. HTTP là giao thức truyền tải siêu văn bản, hoạt động theo cách thức client-server. Sau một thao tác nào đó của người dùng trên web, máy khách sẽ gửi một request đến server và đợi server phản hồi lại. 
Các request của HTTP là các method khác nhau tùy mục đích: method get sử dụng để lấy dữ liệu, method head sử dụng để đọc tiêu đề của các request khác, method put và post cùng được sử dụng để up dữ liệu nhưng điểm khác biệt là PUT là một phương thức bảo toàn dữ liệu còn POST thì không, vì vậy POST thường được sử dụng để tạo 1 resource mới còn PUT thì sử dụng để update resource. method Delete để xóa dữ liệu. Và một số method khác như Connect, options, trace.
Trong phản hồi của server sử dụng sẽ có các status code, các status code cho biết trạng thái của server. Bao gồm 5 nhóm trạng thái: thông tin, thành công, chuyển hướng, lỗi phía client và lỗi phía server. Trong đó có một số status code thường thấy như 200, 302, 403, 404, 500, 503. 
Giao thức quan trọng khác là giao thức NAT, giao thức NAT cho phép các máy tính trong mạng cục bộ có thể đi ra ngoài internet. NAT thường được thực hiện ở thiết bị định tuyến, hoặc server, firewall. Có 3 loại NAT: Source NAT, Des NAT, và Masquerade NAT.
Trong quá trình cấu hình máy chủ, bảo trì cập nhật, chúng ta sẽ cần có một công cụ để truy cập từ xa thay vì đến tận nơi, thì giao thức SSH được sinh ra để làm việc này. Cải tiến từ telnet, SSH có tên là Socket Secure Shell, là giao thức truy cập từ xa có mã hóa dữ liệu. Hoạt động trên tầng ứng dụng và sử dụng cổng TCP 22. SSH có 2 kiểu xác thực là password và keypair. Trong slide mô tả cách mà client xác thực với server bằng cặp khóa công khai và bí mật. đầu tiên ,..
Trên ubuntu, ta sẽ thấy các thông tin xác thực của ssh được lưu ở thư mục .ssh/. Trong thư mục này có chứa các file xác thực như known_hosts cho biết các thiết bị đã từng kết nối. file id_rsa chứa khóa bí mật RSA, file id_rsa.pub chứa khóa công khai RSA, file authoied_keys chứa các khóa công khai của các host đã kết nối. Các cặp khóa có thể được tạo bằng lệnh ssh-keygen, sau đó gửi tới máy ssh server để lưu khóa bí mật. file cấu hình ssh có đường dẫn /etc/ssh/sshd_config, có 2 tùy chọn thường được sử dụng là PermitRootLogin và Pass Auth. SSH agent được sử dụng khi ta sử dụng cách xác thực bằng cặp khóa, khi đã thêm khóa vào ssh-agent thì lúc truy cập ta không cần khai báo nữa, miễn là chưa kết thúc phiên.
Linux có nhiều công cụ cho ta chia sẻ các phiên kết nối SSH. Ta có thể thực hiện tính năng này bằng cách sử dụng các ứng dụng như screen và byobu. 
Thành phần tiếp theo là firewall iptables trên linux, iptables là một interface để tương tác với kernel netfilter của Linux. iptables có thành phần chính gồm các tables, chain và target. Các tables có các chức năng riêng biệt cho từng mục đích, các chain tương ứng với các vị trí của gói tin trong máy tính. các target là những hành động mà iptables thực hiện với gói tin. 
Trên slide là hình ảnh cho thấy mối tương quan giữa các tables và các chain. Có 3 luồng chính mà gói tin có thể đi. Luồng đầu tiên là khi gói tin từ internet vào, luồng thứ 2 là gói tin từ máy tính đi ra internet, gói cuối cùng là gói tin đi đến máy tính rồi được forward đến máy tính khác.
Với các target, có một số hành động mà ta thường dùng là ...
Ta có thể phân luồng dữ liệu linh hoạt bằng policy routing, định tuyến chính sách. Linux lưu thông tin định tuyến dưới dạng các bảng, mỗi bảng có một số ưu tiên, khi gói tin đến, kernel sẽ duyệt qua lần lượt các bảng định tuyến và kiểm tra xem có đường định tuyến nào khớp để thực hiện không. Có 3 bảng mặc định là default, local và main. Bảng ta thường sử dụng là bảng main.
Ngoài định tuyến, ta cũng có thể thực hiện QoS trên Linux với công cụ tc. QoS là quá trình shaping, scheduling, policing, classifying, droping, marking. Để cải thiện hiệu năng của mạng. tc hay traffic control là một tool trong iproute2 package. tc có một số khái niệm cần quan tâm là như qdisc. Qdisc được chia làm 2 loại là qdisc classful và classless. Qdisc classless là qdisc mà không chứa thêm các thành phần khác trong nó, còn qdisc classless thì có thể chứa một qdisc, class hay filter trong nó. Class chỉ chứa trong các qdisc classful, các class có thể chứa class khác hoặc chứa các qdisc khác....










Phần cuối cùng mà em trình bày là về nội dung ảo hóa. Ảo hóa là khái niệm chỉ việc tạo các tài nguyên ảo dựa trên các tài nguyên vật lý, có chức năng giống như các tài nguyên vật lý. Ví dụ như việc tạo LVM để tạo các vùng lưu trữ hay tạo máy ảo. Hypervisor là các chương trình quản lý máy ảo. Chúng chịu trách nhiệm liên kết giữa các tài nguyên phần cứng và thành phần ảo hóa. Hypervisor được chia ra làm 2 loại chính: type1 và type2. type1 là việc ảo hóa trực tiếp chạy ngay trên lớp hardware của máy tính. type 2 thì hypervisor phải được cài đặt trên nền của một hệ điều hành.
Ảo hóa nói chung là về 3 thành phần cơ bản của máy tính: CPU, memory và I/O device. Chi tiết hơn thì có thể chia ra 7 loại: ...
CPU vitualization có một thách thức là kiến trúc nhân x86 dựa trên 4 mức hoạt động, gọi là ring, OS luôn hoạt động ở ring 0 còn ứng dụng người dùng thì hoạt động ở ring 3. Mà các máy ảo nếu không được xử lý ở ring 0 sẽ không thể hoạt động được. Có 3 giải pháp để xử lý việc này, giải pháp 1 là Full Virtualization, Cách tiếp cận này được mô tả trong hình dưới, dịch mã hạt nhân để thay thế các lệnh không thể ảo hóa bằng các chuỗi lệnh mới có tác dụng tương tự ​​trên phần cứng ảo. Trong khi đó, các hoạt động người dùng được thực thi trực tiếp trên bộ xử lý. Với sự kết hợp này, Guest OS thậm chí không biết rằng nó đang được ảo hóa. Giải pháp 2 là Paravirtualization, liên quan đến việc sửa đổi nhân hệ điều hành để thay thế các lệnh non-virtualizable bằng các hypercall giao tiếp trực tiếp với hypervisor lớp ảo hóa. Hypervisor cũng cung cấp các giao diện hypercall cho các hoạt động nhân quan trọng khác như quản lý bộ nhớ, xử lý ngắt và time keeping. Do kernel code của guest OS phải chỉnh sửa nên giải pháp này không thể sử dụng được một số hệ điều hành mã nguồn đóng như windows. Thêm nữa, do guest OS sử dụng hypercall nên nó sẽ biết được nó đang nằm trên một virtualization layer. giải pháp 3 là Hardware virtualization, giải pháp này hướng đến việc xây dựng một CPU mode mới dành riêng cho virtualization layer gọi là root mode ( CPU mode -1), tuy nhiên còn nhiều hạn chế.
Linux sử dụng công cụ ảo hóa là KVM/QEMU, KVM ảo hóa trên nền tảng phần cứng x86 có các module hỗ trợ ảo hóa như Intel VT-x hoặc AMD-V. Về bản chất KVM không thực sự là một hypervisor mà là một module nhân hỗ trợ cơ chế mapping các chỉ dẫn của máy ảo sang chỉ dẫn của máy vật lý mục đích là để tăng hiệu suất cho VM. Còn QEMU thì giống như một hypervisor type 2. QEMU kết hợp với KVM để nhằm tăng hiệu suất của máy ảo. Cấu trúc của KVM kết hợp với QEMU được mô tả như trên slide. Trong đó, phần thấp nhất chính là KVM, cung cấp một module cho hạ tầng ảo hóa. Tầng tiếp theo là virtual machine, chính là các máy ảo được tạo ra bởi QEMU. Lớp tiếp theo là lớp management có thư viện libvirt cung cấp API để hỗ trợ các hypervisor quản lý tài nguyên ảo hóa. Lớp trên cùng là các công cụ quản lý máy ảo cho người dùng,
Các công cụ được cung cấp bởi thư viện libvirt như virt-manager, virt-install, virsh, .. Libvirt chạy một trình nền để quản lý các API và công cụ của nó. Mục đích chính là cung cấp cách quản lý ảo hóa từ các loại hypervisor khác nhau. Ví dụ như khi dùng virsh list nó có thể hiển thị tất cả các máy ảo đang chạy trên các hypervisor khác nhau chứ không cần phải dùng riêng.
Ngoài việc tạo network bằng libvirt, ta có thể sử dụng các công nghệ khác để mở rộng và linh hoạt hơn như linuxbridge. là một modul trong nhân cho phép tạo các switch ảo, thường hay sử dụng cùng lvm/qemu. Nó sẽ kết nối với physical nic để kết nối với mạng bên ngoài. Các NIC vật lý khi kết nối sẽ không sử dụng được IP. lệnh brctl được sử dụng để quản lí linuxbridge.
Openvswitch 








vxlan, webvirt, network mode, lab LAN, LAB vxlan, kvm live migration.
